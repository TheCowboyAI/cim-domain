{
  "aggregates": [
    {
      "details": {
        "module": "saga"
      },
      "kind": "Aggregate",
      "name": "Saga"
    }
  ],
  "bounded_contexts": [
    {
      "id": "formal-domain",
      "modules": [
        "formal_domain",
        "fp_monad"
      ],
      "name": "Formal Domain"
    },
    {
      "id": "cqrs",
      "modules": [
        "cqrs",
        "commands",
        "query_handlers",
        "events"
      ],
      "name": "CQRS"
    },
    {
      "id": "category",
      "modules": [
        "category"
      ],
      "name": "Category Theory"
    },
    {
      "id": "domain",
      "modules": [
        "domain"
      ],
      "name": "Cross-Domain"
    }
  ],
  "category": {
    "composition_rules": [
      {
        "associative": true,
        "notes": "Free monoid fold; identity=[]",
        "rule": "fold(x) ∘ fold(y) = fold(x ∘ y)"
      },
      {
        "associative": true,
        "notes": "Projection functor preserves composition",
        "rule": "P(e2 ∘ e1) = P(e2) ∘ P(e1)"
      },
      {
        "associative": true,
        "notes": "Lift functor between bounded contexts",
        "object": "BoundedContext",
        "rule": "F(id) = id ∧ F(g∘f) = F(g)∘F(f)"
      },
      {
        "associative": true,
        "notes": "Naturality of characteristic maps under pullback",
        "object": "Subobject",
        "rule": "χ_{f*m} = χ_m ∘ f"
      },
      {
        "associative": true,
        "notes": "Type conversion is transitive",
        "rule": "convert(A→B) ∘ convert(B→C) = convert(A→C)"
      },
      {
        "associative": true,
        "notes": "Collections of values form a monoid under concatenation with the empty collection as identity",
        "object": "ValueCollection",
        "rule": "concat(x) ∘ concat(y) = concat(x ∘ y); identity = ∅"
      }
    ],
    "diagrams": [
      {
        "commutes": true,
        "describes": [
          "handled_by",
          "causes_event",
          "emits_event",
          "wraps_event",
          "references_payload_cid",
          "appended_to_stream",
          "collects_envelope"
        ],
        "id": "event_pipeline_v2",
        "path": "doc/act/diagrams/event_pipeline_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "identified_by_command_id",
          "encloses_command",
          "command_carries_identity",
          "identified_by_query_id",
          "encloses_query",
          "query_carries_identity",
          "provides_correlation_id",
          "provides_causation_id",
          "provides_event_id",
          "identifies_event",
          "identifies_aggregate",
          "correlates_with",
          "was_caused_by",
          "describes_payload",
          "command_correlates_to_event",
          "query_correlates_to_event",
          "precedes_envelope",
          "acknowledged_by_command",
          "acknowledged_by_query"
        ],
        "id": "identity_envelope_v2",
        "path": "doc/act/diagrams/identity_envelope_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "subscribes_to_stream",
          "consumes_event",
          "updates_read_model",
          "reads_from",
          "responds_with"
        ],
        "id": "read_path_v2",
        "path": "doc/act/diagrams/read_path_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "domain_cid_defines_node",
          "uses_payload_codec",
          "payload_is",
          "annotated_by_metadata",
          "defined_by_ipld"
        ],
        "id": "addressing_v2",
        "path": "doc/act/diagrams/addressing_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "composes_with_segment",
          "concatenates_with_subject",
          "matches_subject",
          "composes_with_pattern_segment",
          "references_literal_segment"
        ],
        "id": "subject_algebra_v2",
        "path": "doc/act/diagrams/subject_algebra_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "domain_path_composes_with_segment",
          "domain_path_concatenates_with_path",
          "domain_path_addresses_context",
          "domain_path_identifies_facet",
          "domain_artifact_renders_segment"
        ],
        "id": "domain_path_algebra_v2",
        "path": "doc/act/diagrams/domain_path_algebra_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "aggregate_contains_entity",
          "owns_value_collection",
          "collection_contains_value_object",
          "constrained_by_policy",
          "governed_by",
          "emits_event",
          "defines_invariant",
          "enforces_invariant",
          "reports_violation"
        ],
        "id": "aggregate_entity_value_v2",
        "path": "doc/act/diagrams/aggregate_entity_value_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "domain_path_composes_with_segment",
          "domain_path_concatenates_with_path",
          "domain_path_addresses_context",
          "domain_path_identifies_facet",
          "domain_artifact_renders_segment",
          "composes_with_segment",
          "concatenates_with_subject",
          "matches_subject",
          "composes_with_pattern_segment",
          "references_literal_segment",
          "appends_payload_cid",
          "yields_entry",
          "records_cid",
          "locates_bucket",
          "records_move",
          "caused_by",
          "domain_cid_defines_node"
        ],
        "id": "domain_algebra_overview_v2",
        "path": "doc/act/diagrams/domain_algebra_overview_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "scopes_aggregate",
          "scopes_projection",
          "scopes_read_model",
          "scopes_event_stream",
          "scopes_command",
          "scopes_query",
          "scopes_policy",
          "scopes_state_machine",
          "scopes_saga"
        ],
        "id": "bounded_context_scope_v2",
        "path": "doc/act/diagrams/bounded_context_scope_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "refines_concept",
          "part_of",
          "is_partially_equivalent_to",
          "name_entity",
          "specified_by_cim_graph"
        ],
        "id": "concept_graph_v2",
        "path": "doc/act/diagrams/concept_graph_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "owns_value_collection",
          "concat_collections"
        ],
        "id": "ownership_v2",
        "path": "doc/act/diagrams/ownership_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "governed_by",
          "constrained_by_policy",
          "coordinates",
          "manages_participant",
          "maintains_vector_clock"
        ],
        "id": "governance_v2",
        "path": "doc/act/diagrams/governance_v2.dot"
      },
      {
        "commutes": true,
        "describes": [
          "annotated_by_payload_type"
        ],
        "id": "payload_type_v2",
        "path": "doc/act/diagrams/payload_type_v2.dot"
      }
    ],
    "identity_morphisms": [],
    "interpretation": true,
    "morphisms": [
      {
        "id": "refines_concept",
        "name": "RefinesConcept",
        "source": "Concept",
        "target": "Concept",
        "type": "ConceptRelationship"
      },
      {
        "id": "part_of",
        "name": "PartOf",
        "source": "Concept",
        "target": "Concept",
        "type": "ConceptRelationship"
      },
      {
        "id": "is_partially_equivalent_to",
        "name": "IsPartiallyEquivalentTo",
        "source": "Concept",
        "target": "Concept",
        "type": "ConceptRelationship"
      },
      {
        "id": "name_entity",
        "name": "NameEntity",
        "source": "DomainEntity",
        "target": "Concept",
        "type": "NamingRelationship"
      },
      {
        "id": "owns_value_collection",
        "name": "OwnsValueCollection",
        "notes": "Entities own collections of value objects as part of their state",
        "source": "DomainEntity",
        "target": "ValueCollection",
        "type": "Containment"
      },
      {
        "id": "concat_collections",
        "name": "ConcatCollections",
        "notes": "Binary operation (modeled abstractly) representing collection concatenation/union",
        "source": "ValueCollection",
        "target": "ValueCollection",
        "type": "MonoidOperation"
      },
      {
        "id": "defined_by_ipld",
        "name": "DefinedBy",
        "notes": "DomainCid usage is defined by reference to IPLD CID; semantics live in the IPLD domain.",
        "source": "DomainCid",
        "target": "IPLD.Cid",
        "type": "ExternalDefinition"
      },
      {
        "id": "specified_by_cim_graph",
        "name": "SpecifiedBy",
        "notes": "Concept graph semantics are specified by the external cim-graph.",
        "source": "Concept",
        "target": "CIM.Graph",
        "type": "ExternalDefinition"
      },
      {
        "id": "handled_by",
        "name": "HandledBy",
        "notes": "Commands are handled by aggregate roots.",
        "source": "Command",
        "target": "AggregateRoot",
        "type": "HandlingRelationship"
      },
      {
        "id": "emits_event",
        "name": "Emits",
        "notes": "Aggregates emit domain events.",
        "source": "AggregateRoot",
        "target": "DomainEvent",
        "type": "EmissionRelationship"
      },
      {
        "id": "governed_by",
        "name": "GovernedBy",
        "notes": "Aggregate transitions are governed by a state machine.",
        "source": "AggregateRoot",
        "target": "StateMachine",
        "type": "Governance"
      },
      {
        "id": "constrained_by_policy",
        "name": "ConstrainedBy",
        "notes": "Policies constrain aggregate behavior.",
        "source": "AggregateRoot",
        "target": "Policy",
        "type": "Constraint"
      },
      {
        "id": "updates_read_model",
        "name": "Updates",
        "notes": "Projections update read models.",
        "source": "Projection",
        "target": "ReadModel",
        "type": "ProjectionUpdate"
      },
      {
        "id": "consumes_event",
        "name": "Consumes",
        "notes": "Projections consume domain events.",
        "source": "Projection",
        "target": "DomainEvent",
        "type": "Consumption"
      },
      {
        "id": "subscribes_to_stream",
        "name": "SubscribesTo",
        "notes": "Projections subscribe to event streams.",
        "source": "Projection",
        "target": "EventStream",
        "type": "Subscription"
      },
      {
        "id": "appended_to_stream",
        "name": "AppendedTo",
        "notes": "Event envelopes are appended to event streams.",
        "source": "DomainEventEnvelope",
        "target": "EventStream",
        "type": "Append"
      },
      {
        "id": "wraps_event",
        "name": "Wraps",
        "notes": "Envelopes wrap domain events (inline or by CID).",
        "source": "DomainEventEnvelope",
        "target": "DomainEvent",
        "type": "Envelope"
      },
      {
        "id": "references_payload_cid",
        "name": "ReferencesPayloadCid",
        "notes": "Envelope payload may be content-addressed (CID).",
        "source": "DomainEventEnvelope",
        "target": "DomainCid",
        "type": "Reference"
      },
      {
        "id": "reads_from",
        "name": "ReadsFrom",
        "notes": "Queries read from read models.",
        "source": "Query",
        "target": "ReadModel",
        "type": "Read"
      },
      {
        "id": "responds_with",
        "name": "RespondsWith",
        "notes": "Queries respond with a QueryResponse value object.",
        "source": "Query",
        "target": "QueryResponse",
        "type": "Response"
      },
      {
        "id": "coordinates",
        "name": "Coordinates",
        "notes": "Saga coordinates multiple aggregates.",
        "source": "Saga",
        "target": "AggregateRoot",
        "type": "Coordination"
      },
      {
        "id": "scopes_aggregate",
        "name": "Scopes",
        "notes": "BoundedContext scopes aggregates.",
        "source": "BoundedContext",
        "target": "AggregateRoot",
        "type": "Containment"
      },
      {
        "id": "scopes_projection",
        "name": "Scopes",
        "notes": "BoundedContext scopes projections.",
        "source": "BoundedContext",
        "target": "Projection",
        "type": "Containment"
      },
      {
        "id": "scopes_read_model",
        "name": "Scopes",
        "notes": "BoundedContext scopes read models.",
        "source": "BoundedContext",
        "target": "ReadModel",
        "type": "Containment"
      },
      {
        "id": "scopes_event_stream",
        "name": "Scopes",
        "notes": "BoundedContext scopes event streams.",
        "source": "BoundedContext",
        "target": "EventStream",
        "type": "Containment"
      },
      {
        "id": "causes_event",
        "name": "Causes",
        "notes": "Command handling causes domain events.",
        "source": "Command",
        "target": "DomainEvent",
        "type": "Causation"
      },
      {
        "id": "manages_participant",
        "name": "ManagesParticipant",
        "notes": "Saga manages participant aggregates.",
        "source": "Saga",
        "target": "AggregateRoot",
        "type": "Containment"
      },
      {
        "id": "maintains_vector_clock",
        "name": "MaintainsVectorClock",
        "notes": "Saga maintains a vector clock for causal ordering across participants.",
        "source": "Saga",
        "target": "VectorClock",
        "type": "CausalityTracking"
      },
      {
        "id": "identified_by_command_id",
        "name": "IdentifiedBy",
        "notes": "CommandEnvelope is identified by CommandId",
        "source": "CommandEnvelope",
        "target": "CommandId",
        "type": "Identity"
      },
      {
        "id": "encloses_command",
        "name": "Encloses",
        "notes": "CommandEnvelope encloses a Command",
        "source": "CommandEnvelope",
        "target": "Command",
        "type": "Envelope"
      },
      {
        "id": "command_carries_identity",
        "name": "CarriesIdentity",
        "notes": "CommandEnvelope includes MessageIdentity for correlation/causation",
        "source": "CommandEnvelope",
        "target": "MessageIdentity",
        "type": "Identity"
      },
      {
        "id": "identified_by_query_id",
        "name": "IdentifiedBy",
        "notes": "QueryEnvelope is identified by QueryId",
        "source": "QueryEnvelope",
        "target": "QueryId",
        "type": "Identity"
      },
      {
        "id": "encloses_query",
        "name": "Encloses",
        "notes": "QueryEnvelope encloses a Query",
        "source": "QueryEnvelope",
        "target": "Query",
        "type": "Envelope"
      },
      {
        "id": "query_carries_identity",
        "name": "CarriesIdentity",
        "notes": "QueryEnvelope includes MessageIdentity for correlation/causation",
        "source": "QueryEnvelope",
        "target": "MessageIdentity",
        "type": "Identity"
      },
      {
        "id": "provides_correlation_id",
        "name": "ProvidesCorrelationId",
        "notes": "MessageIdentity provides a CorrelationId",
        "source": "MessageIdentity",
        "target": "CorrelationId",
        "type": "Identity"
      },
      {
        "id": "provides_causation_id",
        "name": "ProvidesCausationId",
        "notes": "MessageIdentity provides a CausationId",
        "source": "MessageIdentity",
        "target": "CausationId",
        "type": "Identity"
      },
      {
        "id": "provides_command_message_id",
        "name": "ProvidesCommandMessageId",
        "notes": "MessageIdentity can carry a command message id (context-dependent)",
        "source": "MessageIdentity",
        "target": "CommandId",
        "type": "Identity"
      },
      {
        "id": "provides_query_message_id",
        "name": "ProvidesQueryMessageId",
        "notes": "MessageIdentity can carry a query message id (context-dependent)",
        "source": "MessageIdentity",
        "target": "QueryId",
        "type": "Identity"
      },
      {
        "id": "provides_event_id",
        "name": "ProvidesEventId",
        "notes": "MessageIdentity can carry an event id (context-dependent)",
        "source": "MessageIdentity",
        "target": "EventId",
        "type": "Identity"
      },
      {
        "id": "identifies_event",
        "name": "IdentifiesEvent",
        "notes": "DomainEventEnvelope carries an EventId",
        "source": "DomainEventEnvelope",
        "target": "EventId",
        "type": "Identity"
      },
      {
        "id": "identifies_aggregate",
        "name": "IdentifiesAggregate",
        "notes": "DomainEventEnvelope duplicates the aggregate id for post-persist access",
        "source": "DomainEventEnvelope",
        "target": "EntityId",
        "type": "Identity"
      },
      {
        "id": "correlates_with",
        "name": "CorrelatesWith",
        "notes": "DomainEventEnvelope carries a CorrelationId",
        "source": "DomainEventEnvelope",
        "target": "CorrelationId",
        "type": "Identity"
      },
      {
        "id": "was_caused_by",
        "name": "WasCausedBy",
        "notes": "DomainEventEnvelope carries a CausationId",
        "source": "DomainEventEnvelope",
        "target": "CausationId",
        "type": "Identity"
      },
      {
        "id": "describes_payload",
        "name": "DescribesPayload",
        "notes": "Envelope includes PayloadMetadata describing the payload",
        "source": "DomainEventEnvelope",
        "target": "PayloadMetadata",
        "type": "Metadata"
      },
      {
        "id": "uses_payload_codec",
        "name": "UsesPayloadCodec",
        "notes": "DomainNode payload is encoded with a DomainPayloadCodec",
        "source": "DomainNode",
        "target": "DomainPayloadCodec",
        "type": "Annotation"
      },
      {
        "id": "annotated_by_payload_type",
        "name": "AnnotatedByPayloadType",
        "notes": "DomainNode optionally records the domain payload type (Event/Aggregate/ValueObject/Document/Raw)",
        "source": "DomainNode",
        "target": "DomainPayloadType",
        "type": "Annotation"
      },
      {
        "id": "payload_is",
        "name": "PayloadIs",
        "notes": "DomainNode references an IPLD payload CID",
        "source": "DomainNode",
        "target": "IPLD.Cid",
        "type": "Reference"
      },
      {
        "id": "annotated_by_metadata",
        "name": "AnnotatedByMetadata",
        "notes": "DomainNode has typed metadata values",
        "source": "DomainNode",
        "target": "ValueObject",
        "type": "Metadata"
      },
      {
        "id": "domain_cid_defines_node",
        "name": "DefinesNode",
        "notes": "The root DomainCid defines the DomainNode envelope",
        "source": "DomainCid",
        "target": "DomainNode",
        "type": "Definition"
      },
      {
        "id": "composes_with_segment",
        "name": "ComposesWithSegment",
        "notes": "Subject is composed from ordered SubjectSegment tokens",
        "source": "Subject",
        "target": "SubjectSegment",
        "type": "Composition"
      },
      {
        "id": "concatenates_with_subject",
        "name": "ConcatenatesWith",
        "notes": "Subjects concatenate via free monoid operation",
        "source": "Subject",
        "target": "Subject",
        "type": "Operation"
      },
      {
        "id": "matches_subject",
        "name": "MatchesSubject",
        "notes": "SubjectPattern evaluates against concrete Subject instances",
        "source": "SubjectPattern",
        "target": "Subject",
        "type": "Matching"
      },
      {
        "id": "composes_with_pattern_segment",
        "name": "ComposesWithPatternSegment",
        "notes": "SubjectPattern is composed from pattern segment variants",
        "source": "SubjectPattern",
        "target": "SubjectPatternSegment",
        "type": "Composition"
      },
      {
        "id": "references_literal_segment",
        "name": "ReferencesLiteralSegment",
        "notes": "Pattern segments reference literal SubjectSegment when not wildcard",
        "source": "SubjectPatternSegment",
        "target": "SubjectSegment",
        "type": "Reference"
      },
      {
        "id": "domain_path_composes_with_segment",
        "name": "ComposesWithSegment",
        "notes": "DomainPath is composed from ordered DomainPathSegment tokens",
        "source": "DomainPath",
        "target": "DomainPathSegment",
        "type": "Composition"
      },
      {
        "id": "domain_path_concatenates_with_path",
        "name": "ConcatenatesWith",
        "notes": "DomainPath values concatenate using the cim.domain identity",
        "source": "DomainPath",
        "target": "DomainPath",
        "type": "Operation"
      },
      {
        "id": "domain_path_addresses_context",
        "name": "AddressesContext",
        "notes": "A DomainPath resolves to a specific BoundedContext (third segment)",
        "source": "DomainPath",
        "target": "BoundedContext",
        "type": "Reference"
      },
      {
        "id": "domain_path_identifies_facet",
        "name": "IdentifiesFacet",
        "notes": "DomainPath exposes a DomainArtifactKind describing the addressed facet",
        "source": "DomainPath",
        "target": "DomainArtifactKind",
        "type": "Classification"
      },
      {
        "id": "domain_artifact_renders_segment",
        "name": "RendersAsSegment",
        "notes": "DomainArtifactKind renders to the canonical path segment string",
        "source": "DomainArtifactKind",
        "target": "DomainPathSegment",
        "type": "Annotation"
      },
      {
        "id": "aggregate_contains_entity",
        "name": "ContainsEntity",
        "notes": "Aggregates encapsulate one or more domain entities within their boundary",
        "source": "AggregateRoot",
        "target": "DomainEntity",
        "type": "Containment"
      },
      {
        "id": "collection_contains_value_object",
        "name": "ContainsValueObject",
        "notes": "Value collections store the value objects owned by an entity",
        "source": "ValueCollection",
        "target": "ValueObject",
        "type": "Containment"
      },
      {
        "id": "defines_invariant",
        "name": "DefinesInvariant",
        "notes": "Policies declare the invariants that aggregates must enforce",
        "source": "Policy",
        "target": "DomainInvariant",
        "type": "Definition"
      },
      {
        "id": "enforces_invariant",
        "name": "EnforcesInvariant",
        "notes": "Aggregates enforce domain invariants as part of transaction boundaries",
        "source": "AggregateRoot",
        "target": "DomainInvariant",
        "type": "Constraint"
      },
      {
        "id": "reports_violation",
        "name": "ReportsViolation",
        "notes": "Invariants emit structured violations when checks fail",
        "source": "DomainInvariant",
        "target": "InvariantViolation",
        "type": "Observation"
      },
      {
        "id": "acknowledged_by_command",
        "name": "AcknowledgedBy",
        "notes": "Commands are acknowledged by CommandAcknowledgment",
        "source": "Command",
        "target": "CommandAcknowledgment",
        "type": "Acknowledgment"
      },
      {
        "id": "acknowledged_by_query",
        "name": "AcknowledgedBy",
        "notes": "Queries are acknowledged by QueryAcknowledgment",
        "source": "Query",
        "target": "QueryAcknowledgment",
        "type": "Acknowledgment"
      },
      {
        "id": "collects_envelope",
        "name": "CollectsEnvelope",
        "notes": "EventStream collects DomainEventEnvelopes appended to it",
        "source": "EventStream",
        "target": "DomainEventEnvelope",
        "type": "Containment"
      },
      {
        "id": "command_correlates_to_event",
        "name": "CorrelatesTo",
        "notes": "CommandEnvelope correlates to resulting DomainEventEnvelopes (via correlation id)",
        "source": "CommandEnvelope",
        "target": "DomainEventEnvelope",
        "type": "Correlation"
      },
      {
        "id": "query_correlates_to_event",
        "name": "CorrelatesTo",
        "notes": "QueryEnvelope correlates to DomainEventEnvelopes (via correlation id)",
        "source": "QueryEnvelope",
        "target": "DomainEventEnvelope",
        "type": "Correlation"
      },
      {
        "id": "precedes_envelope",
        "name": "Precedes",
        "notes": "Event envelopes are partially ordered by EventId v7 (time order)",
        "source": "DomainEventEnvelope",
        "target": "DomainEventEnvelope",
        "type": "Temporal"
      },
      {
        "id": "scopes_command",
        "name": "Scopes",
        "notes": "BoundedContext scopes commands",
        "source": "BoundedContext",
        "target": "Command",
        "type": "Containment"
      },
      {
        "id": "scopes_query",
        "name": "Scopes",
        "notes": "BoundedContext scopes queries",
        "source": "BoundedContext",
        "target": "Query",
        "type": "Containment"
      },
      {
        "id": "scopes_policy",
        "name": "Scopes",
        "notes": "BoundedContext scopes policies",
        "source": "BoundedContext",
        "target": "Policy",
        "type": "Containment"
      },
      {
        "id": "scopes_state_machine",
        "name": "Scopes",
        "notes": "BoundedContext scopes state machines",
        "source": "BoundedContext",
        "target": "StateMachine",
        "type": "Containment"
      },
      {
        "id": "scopes_saga",
        "name": "Scopes",
        "notes": "BoundedContext scopes sagas",
        "source": "BoundedContext",
        "target": "Saga",
        "type": "Containment"
      }
    ],
    "name": "CIM-Domain-Category",
    "notes": "Category is an interpretation lens over the domain, not the domain itself.",
    "objects": [
      {
        "id": "EntityId",
        "name": "EntityId<T>",
        "type": "ValueObject"
      },
      {
        "id": "DomainEventEnvelope",
        "name": "DomainEventEnvelope",
        "type": "Event"
      },
      {
        "id": "AggregateRoot",
        "name": "AggregateRoot",
        "type": "Trait"
      },
      {
        "id": "DomainEvent",
        "name": "DomainEvent",
        "type": "Event"
      },
      {
        "id": "Command",
        "name": "Command",
        "type": "Command"
      },
      {
        "id": "StateMachine",
        "name": "StateMachine",
        "type": "Concept"
      },
      {
        "id": "Projection",
        "name": "Projection",
        "type": "Projection"
      },
      {
        "id": "ReadModel",
        "name": "ReadModel",
        "type": "ReadModel"
      },
      {
        "id": "QueryResponse",
        "name": "QueryResponse",
        "type": "ValueObject"
      },
      {
        "id": "EventStream",
        "name": "EventStream",
        "type": "Concept"
      },
      {
        "id": "CommandEnvelope",
        "name": "CommandEnvelope",
        "type": "Concept"
      },
      {
        "id": "QueryEnvelope",
        "name": "QueryEnvelope",
        "type": "Concept"
      },
      {
        "id": "MessageIdentity",
        "name": "MessageIdentity",
        "type": "Concept"
      },
      {
        "id": "Saga",
        "name": "Saga",
        "type": "Aggregate"
      },
      {
        "id": "BoundedContext",
        "name": "BoundedContext",
        "type": "Context"
      },
      {
        "id": "Concept",
        "name": "Concept",
        "type": "Concept"
      },
      {
        "id": "Query",
        "name": "Query",
        "type": "Query"
      },
      {
        "details": {
          "domain": "cim-graph",
          "notes": "External specification of concept graphs; we reference it rather than redefine.",
          "reference": "cim-graph:concept_graph (external)"
        },
        "id": "CIM.Graph",
        "name": "cim-graph:concept_graph",
        "type": "External"
      },
      {
        "id": "DomainCid",
        "name": "DomainCid",
        "type": "ValueObject"
      },
      {
        "details": {
          "notes": "Validated dotted subject used for routing and addressing; forms a free monoid over SubjectSegment with concatenation."
        },
        "id": "Subject",
        "name": "Subject",
        "type": "ValueObject"
      },
      {
        "details": {
          "notes": "Single token within a subject; excludes delimiters and wildcard characters."
        },
        "id": "SubjectSegment",
        "name": "SubjectSegment",
        "type": "ValueObject"
      },
      {
        "details": {
          "notes": "Subject with wildcard support for subscriptions; retains value object semantics."
        },
        "id": "SubjectPattern",
        "name": "SubjectPattern",
        "type": "ValueObject"
      },
      {
        "details": {
          "notes": "Pattern segment variant capturing literals, single wildcards, or terminal multi-segment wildcard."
        },
        "id": "SubjectPatternSegment",
        "name": "SubjectPatternSegment",
        "type": "ValueObject"
      },
      {
        "details": {
          "notes": "Canonical dotted path rooted at cim.domain that composes bounded context and facet tokens."
        },
        "id": "DomainPath",
        "name": "DomainPath",
        "type": "ValueObject"
      },
      {
        "details": {
          "notes": "Validated token inside a DomainPath (lowercase, digits, underscore and dash)."
        },
        "id": "DomainPathSegment",
        "name": "DomainPathSegment",
        "type": "ValueObject"
      },
      {
        "details": {
          "notes": "Classifier for domain path facets (command, aggregate, value, saga, etc.)."
        },
        "id": "DomainArtifactKind",
        "name": "DomainArtifactKind",
        "type": "Concept"
      },
      {
        "details": {
          "notes": "Codec annotation for DomainNode payload blocks (raw/dag-cbor/dag-json)."
        },
        "id": "DomainPayloadCodec",
        "name": "DomainPayloadCodec",
        "type": "Concept"
      },
      {
        "details": {
          "notes": "Cross-aggregate constraint definitions enforcing business rules across entities." 
        },
        "id": "DomainInvariant",
        "name": "DomainInvariant",
        "type": "Concept"
      },
      {
        "details": {
          "notes": "Structured report describing how an invariant was violated." 
        },
        "id": "InvariantViolation",
        "name": "InvariantViolation",
        "type": "ValueObject"
      },
      {
        "id": "Policy",
        "name": "Policy",
        "type": "Concept"
      },
      {
        "details": {
          "semantics": "A collection of value objects owned by an entity; shape-agnostic (sequence/set/bag). Choose an operation consistent with shape: concat for ordered sequences, union for sets, multiset-union for bags. Identity is the empty collection; laws are monoid laws (associativity, identity)."
        },
        "id": "ValueCollection",
        "name": "ValueCollection",
        "type": "Concept"
      },
      {
        "details": {
          "domain": "ipld",
          "notes": "External domain object reference; we do not redefine CID; we reference it for usage.",
          "reference": "ipld:cid (external)"
        },
        "id": "IPLD.Cid",
        "name": "ipld:cid",
        "type": "External"
      },
      {
        "details": {
          "definition": "Immutable domain object defined solely by its attributes; no identity beyond value; compared by structural equality; used as measurement or descriptor in the domain."
        },
        "id": "ValueObject",
        "name": "ValueObject",
        "type": "Concept"
      },
      {
        "id": "DomainEntity",
        "name": "DomainEntity",
        "type": "Entity"
      },
      {
        "id": "CommandId",
        "name": "CommandId",
        "type": "ValueObject"
      },
      {
        "id": "QueryId",
        "name": "QueryId",
        "type": "ValueObject"
      },
      {
        "id": "EventId",
        "name": "EventId",
        "type": "ValueObject"
      },
      {
        "id": "AggregateTransactionId",
        "name": "AggregateTransactionId",
        "type": "ValueObject"
      },
      {
        "id": "CorrelationId",
        "name": "CorrelationId",
        "type": "ValueObject"
      },
      {
        "id": "CausationId",
        "name": "CausationId",
        "type": "ValueObject"
      },
      {
        "id": "CommandAcknowledgment",
        "name": "CommandAcknowledgment",
        "type": "Concept"
      },
      {
        "id": "QueryAcknowledgment",
        "name": "QueryAcknowledgment",
        "type": "Concept"
      },
      {
        "id": "EventStreamSubscription",
        "name": "EventStreamSubscription",
        "type": "Concept"
      },
      {
        "id": "DomainNode",
        "name": "DomainNode",
        "type": "Concept"
      },
      {
        "id": "PayloadMetadata",
        "name": "PayloadMetadata",
        "type": "Concept"
      },
      {
        "id": "DomainPayloadType",
        "name": "DomainPayloadType",
        "type": "Concept"
      }
    ]
  },
  "domain": {
    "id": "cim-domain",
    "name": "CIM Domain",
    "organization": "Cowboy AI, LLC",
    "purpose": "Foundational DDD primitives and formal structures for CIM",
    "version": "0.1.0"
  },
  "domain_identity": {
    "core_concepts": [
      "schema",
      "language",
      "metacognition"
    ],
    "notes": "This domain models foundational DDD primitives and UL projections; it composes other domains via functors.",
    "ul_concept_id": "cim_domain"
  },
  "entities": [
    {
      "details": {
        "module": "entity"
      },
      "kind": "Entity",
      "name": "Entity<T>"
    },
    {
      "details": {
        "module": "events"
      },
      "kind": "Entity",
      "name": "DomainEventEnvelope"
    }
  ],
  "metadata": {
    "isomorphic_to": {
      "ast": {
        "root_module": "src/lib.rs",
        "verified": true
      },
      "string_diagrams": {
        "files": [
          "doc/act/diagrams/event_pipeline_v2.dot",
          "doc/act/diagrams/identity_envelope_v2.dot",
          "doc/act/diagrams/read_path_v2.dot",
      "doc/act/diagrams/addressing_v2.dot",
      "doc/act/diagrams/subject_algebra_v2.dot",
      "doc/act/diagrams/domain_path_algebra_v2.dot",
      "doc/act/diagrams/aggregate_entity_value_v2.dot",
      "doc/act/diagrams/domain_algebra_overview_v2.dot",
      "doc/act/diagrams/bounded_context_scope_v2.dot",
          "doc/act/diagrams/concept_graph_v2.dot",
          "doc/act/diagrams/ownership_v2.dot",
          "doc/act/diagrams/governance_v2.dot",
          "doc/act/diagrams/payload_type_v2.dot"
        ],
        "proofs_location": "doc/act/string_diagrams.md",
        "verified": true
      }
    }
  },
  "relationships": [],
  "ul_projection": {
    "file": "ul-projection.json",
    "notes": "Run diff-first using tools/domain_graph/ul_projection to review UL changes; do not auto-overwrite.",
    "verified": true
  },
  "value_objects": [
    {
      "details": {
        "module": "cid",
        "multihash": "blake3-256 (0x1e)",
        "notes": "DomainCid supports dag-cbor, dag-json, and rarely raw for payload blocks (based on mimetype). DomainNode adds a typed KV metadata object; the top-level CID is a merkledag root containing metadata and references to the payload and invariants.",
        "payload_codecs": [
          "dag-cbor",
          "dag-json",
          "raw (rare)"
        ],
        "version": "1"
      },
      "kind": "ValueObject",
      "name": "DomainCid"
    },
    {
      "details": {
        "module": "cid"
      },
      "kind": "ValueObject",
      "name": "CidChain"
    },
    {
      "details": {
        "module": "entity"
      },
      "kind": "ValueObject",
      "name": "EntityId<T>"
    },
    {
      "details": {
        "module": "vector_clock"
      },
      "kind": "ValueObject",
      "name": "VectorClock"
    }
  ]
}
