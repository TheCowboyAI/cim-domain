<!-- Copyright 2025 Cowboy AI, LLC. -->

# Correlation and Causation Design in CIM

## Overview

In CIM's event-driven architecture, tracking message relationships is crucial for understanding system behavior and maintaining audit trails. This document explains how correlation and causation work in our CQRS implementation.

## Key Concepts

### Correlation ID
- **Purpose**: Groups related messages together across the entire workflow
- **Default Behavior**: For the first message in a chain, the correlation ID is a self-reference
- **Propagation**: All subsequent messages in the workflow share the same correlation ID
- **Example**: A root command starts a correlation chain that includes all related events, queries, and subsequent commands within the same business conversation

### Causation ID
- **Purpose**: Identifies what specific message caused this message to be created
- **Requirement**: MUST reference an existing message that has already been processed
- **Optional**: Only messages that are caused by other messages have a causation ID
- **Example**: An event caused by a command will have that command's ID as its causation ID

## ID Type System

### IdType Enum
```rust
pub enum IdType {
    Uuid(Uuid),       // Default identity for domain messages (v7 recommended)
    // Downstream crates may introduce content-addressed IDs
}
```

### CorrelationId and CausationId
```rust
pub struct CorrelationId(pub IdType);
pub struct CausationId(pub IdType);
```

Both correlation and causation IDs use the same underlying `IdType` enum. In this library we default to UUID v7; downstream crates may adopt content-addressed IDs.

## Usage Patterns

### Starting a New Correlation Chain
```rust
// Root command starts a new correlation
let envelope = CommandEnvelope::new(
    GenericCommand { /* ... /* }, "actor@example.com"
);
// envelope.correlation_id = CorrelationId(IdType::Uuid(envelope.id))
// envelope.causation_id = None
```

### Continuing a Correlation Chain
```rust
// Command caused by an event continues the correlation
let envelope = CommandEnvelope::from_event(
    GenericCommand { /* ... /* }, "service-b",
    causing_message_id,     // The message that triggered this
    original_correlation,   // Maintains the original correlation
);
// envelope.correlation_id = original_correlation
// envelope.causation_id = Some(CausationId(causing_message_id))
```

## Message Flow Example

```
1. Actor submits a root command
   - correlation: CorrelationId(IdType::Uuid(command.123))  // self-reference
   - causation: None

2. A domain event is published
   - correlation: CorrelationId(IdType::Uuid(command.123))  // from original command
   - causation: CausationId(IdType::Uuid(command.123))

3. A system reads a read model (triggered by event)
   - correlation: CorrelationId(IdType::Uuid(command.123))  // maintains chain
   - causation: CausationId(IdType::Cid(event.abc))         // the prior event

4. Another domain event is published
   - correlation: CorrelationId(IdType::Uuid(command.123))  // maintains chain
   - causation: CausationId(IdType::Uuid(query.456))        // the query that caused the event
```

## Benefits

1. **Traceability**: Complete audit trail of what caused what
2. **Debugging**: Easy to follow message chains through the system
3. **Analytics**: Understand system behavior and performance
4. **Compliance**: Maintain required audit logs for regulatory purposes
5. **Type Safety**: The `IdType` enum ensures we can only reference valid message types

## Implementation Notes

- Timestamps are NOT generated by the domain layer - they come from infrastructure (downstream)
- Correlation IDs enable subscribing to all messages in a workflow
- Causation IDs must reference messages that already exist in the system
- The first message in any chain has a self-referential correlation ID
- The `IdType` enum provides type safety while allowing flexibility in what can be correlated or caused
