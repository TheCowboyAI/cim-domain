<!-- Copyright 2025 Cowboy AI, LLC. -->

# Correlation and Causation Design in CIM

## Overview

In CIM's event-driven architecture, tracking message relationships is crucial for understanding system behavior and maintaining audit trails. This document explains how correlation and causation work in our CQRS implementation.

## Key Concepts

### Correlation ID
- **Purpose**: Groups related messages together across the entire workflow
- **Default Behavior**: For the first message in a chain, the correlation ID is a self-reference
- **Propagation**: All subsequent messages in the workflow share the same correlation ID
- **Example**: A user command to create an order starts a correlation chain that includes all related events, queries, and subsequent commands

### Causation ID
- **Purpose**: Identifies what specific message caused this message to be created
- **Requirement**: MUST reference an existing message that has already been processed
- **Optional**: Only messages that are caused by other messages have a causation ID
- **Example**: An event caused by a command will have that command's ID as its causation ID

## ID Type System

### IdType Enum
```rust
pub enum IdType {
    Uuid(Uuid),  // For commands and queries
    Cid(Cid),    // For events (content-addressed)
}
```

### CorrelationId and CausationId
```rust
pub struct CorrelationId(pub IdType);
pub struct CausationId(pub IdType);
```

Both correlation and causation IDs use the same underlying `IdType` enum, which can hold either:
- **UUID**: For referencing commands and queries
- **CID**: For referencing events (content-addressed for immutability)

## Usage Patterns

### Starting a New Correlation Chain
```rust
// User-initiated command starts a new correlation
let envelope = CommandEnvelope::new(
    CreateOrder { ... },
    "user@example.com"
);
// envelope.correlation_id = CorrelationId(IdType::Uuid(envelope.id))
// envelope.causation_id = None
```

### Continuing a Correlation Chain
```rust
// Command caused by an event continues the correlation
let envelope = CommandEnvelope::from_event(
    ProcessPayment { ... },
    "payment-service",
    causing_event_cid,      // The event that triggered this
    original_correlation,   // Maintains the original correlation
);
// envelope.correlation_id = original_correlation
// envelope.causation_id = Some(CausationId(IdType::Cid(causing_event_cid)))
```

## Message Flow Example

```
1. User submits CreateOrder command
   - correlation: CorrelationId(IdType::Uuid(command.123))  // self-reference
   - causation: None

2. OrderCreated event published
   - correlation: CorrelationId(IdType::Uuid(command.123))  // from original command
   - causation: CausationId(IdType::Uuid(command.123))

3. System queries inventory (triggered by event)
   - correlation: CorrelationId(IdType::Uuid(command.123))  // maintains chain
   - causation: CausationId(IdType::Cid(event.abc))         // the OrderCreated event

4. InventoryReserved event published
   - correlation: CorrelationId(IdType::Uuid(command.123))  // maintains chain
   - causation: CausationId(IdType::Uuid(query.456))        // the inventory query
```

## Benefits

1. **Traceability**: Complete audit trail of what caused what
2. **Debugging**: Easy to follow message chains through the system
3. **Analytics**: Understand system behavior and performance
4. **Compliance**: Maintain required audit logs for regulatory purposes
5. **Type Safety**: The `IdType` enum ensures we can only reference valid message types

## Implementation Notes

- Timestamps are NOT generated by the domain layer - they come from the message infrastructure (NATS, in-memory, etc.)
- Correlation IDs enable subscribing to all messages in a workflow
- Causation IDs must reference messages that already exist in the system
- The first message in any chain has a self-referential correlation ID
- The `IdType` enum provides type safety while allowing flexibility in what can be correlated or caused
