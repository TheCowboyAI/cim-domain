//! Domain events for CIM
//!
//! Events represent facts that have occurred in the domain. They are immutable
//! and form the basis of event sourcing and event-driven communication.

use crate::{
    cqrs::{CorrelationId, CausationId, EventId, IdType},
    location::{Address, LocationType, GeoCoordinates, VirtualLocation},
};
use cim_subject::Subject as SubjectParts;
use cid::Cid;
use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use uuid::Uuid;

/// Propagation scope for event escalation (orthogonal to subjects)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PropagationScope {
    /// Never leaves the app
    LocalOnly,
    /// May bubble to container
    Container,
    /// May bubble to local leaf
    Leaf,
    /// May bubble to cluster
    Cluster,
    /// May bubble globally
    SuperCluster,
}

/// Event envelope with subject and propagation scope
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventEnvelope<E> {
    /// The domain event
    pub event: E,
    /// Subject for routing (e.g., "people.person.registered.v1")
    pub subject: String,
    /// Determines if/how to escalate
    pub propagation: PropagationScope,
}

/// Base trait for all domain events
pub trait DomainEvent: Send + Sync + std::fmt::Debug {
    /// Get the subject for this event
    fn subject(&self) -> String;

    /// Get the aggregate ID this event relates to
    fn aggregate_id(&self) -> Uuid;

    /// Get the event type name
    fn event_type(&self) -> &'static str;

    /// Get the schema version
    fn version(&self) -> &'static str {
        "v1"
    }
}

/// Envelope for domain events with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEventEnvelopeWithMetadata<E: DomainEvent> {
    /// The event ID
    pub event_id: EventId,

    /// The actual event
    pub event: E,

    /// When the event occurred
    pub occurred_at: SystemTime,

    /// Correlation ID for tracking across services
    pub correlation_id: CorrelationId,

    /// ID of the event that caused this one
    pub causation_id: CausationId,

    /// Metadata for routing and processing
    pub metadata: EventMetadata,
}

/// Metadata for event processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventMetadata {
    /// Source service/context
    pub source: String,

    /// Event version
    pub version: String,

    /// Propagation scope
    pub propagation_scope: PropagationScope,

    /// Additional metadata
    pub properties: std::collections::HashMap<String, serde_json::Value>,
}

/// Wrapper for domain events with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEventEnvelope<E> {
    /// Event metadata
    pub metadata: EventMetadata,

    /// The actual event
    pub event: E,

    /// NATS subject for routing
    pub subject: String,
}

impl<E: DomainEvent> DomainEventEnvelope<E> {
    /// Create a new event envelope
    pub fn new(event: E, metadata: EventMetadata) -> Self {
        let subject = event.subject();
        Self {
            metadata,
            event,
            subject,
        }
    }

    /// Parse the subject into components
    pub fn subject_parts(&self) -> crate::DomainResult<SubjectParts> {
        SubjectParts::new(&self.subject).map_err(|e| crate::DomainError::InvalidSubject(e.to_string()))
    }
}

impl<E: DomainEvent> DomainEventEnvelopeWithMetadata<E> {
    /// Create a new event envelope
    /// Note: event_id (CID) will be generated by the event store from the content
    pub fn new(event: E, triggered_by: String) -> Self {
        Self {
            event_id: Cid::default(), // Placeholder - will be replaced by event store
            event,
            occurred_at: SystemTime::now(),
            correlation_id: CorrelationId(IdType::Uuid(Uuid::new_v4())),
            causation_id: CausationId(IdType::Uuid(Uuid::new_v4())),
            metadata: EventMetadata {
                source: triggered_by,
                version: "v1".to_string(),
                propagation_scope: PropagationScope::LocalOnly,
                properties: std::collections::HashMap::new(),
            },
        }
    }

    /// Create from a command
    /// Note: event_id (CID) will be generated by the event store from the content
    pub fn from_command(event: E, command_id: Uuid, triggered_by: String) -> Self {
        Self {
            event_id: Cid::default(), // Placeholder - will be replaced by event store
            event,
            occurred_at: SystemTime::now(),
            correlation_id: CorrelationId(IdType::Uuid(command_id)),
            causation_id: CausationId(IdType::Uuid(command_id)),
            metadata: EventMetadata {
                source: triggered_by,
                version: "v1".to_string(),
                propagation_scope: PropagationScope::LocalOnly,
                properties: std::collections::HashMap::new(),
            },
        }
    }

    /// Create from another event (for event chains)
    /// Note: event_id (CID) will be generated by the event store from the content
    pub fn from_event(
        event: E,
        causing_event: EventId,
        correlation_id: CorrelationId,
        triggered_by: String,
    ) -> Self {
        Self {
            event_id: Cid::default(), // Placeholder - will be replaced by event store
            event,
            occurred_at: SystemTime::now(),
            correlation_id,
            causation_id: CausationId(IdType::Cid(causing_event)),
            metadata: EventMetadata {
                source: triggered_by,
                version: "v1".to_string(),
                propagation_scope: PropagationScope::LocalOnly,
                properties: std::collections::HashMap::new(),
            },
        }
    }

    /// Set propagation scope
    pub fn with_propagation(mut self, scope: PropagationScope) -> Self {
        self.metadata.propagation_scope = scope;
        self
    }

    /// Set the actual CID after it's been calculated from content
    pub fn with_cid(mut self, cid: Cid) -> Self {
        self.event_id = cid;
        self
    }
}

// Example domain events for core entities

/// Location defined
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocationDefined {
    /// The unique identifier of the location
    pub location_id: Uuid,
    /// The name of the location
    pub name: String,
    /// The type of location (physical, virtual, etc.)
    pub location_type: LocationType,
    /// The physical address (if applicable)
    pub address: Option<Address>,
    /// The geographic coordinates (if applicable)
    pub coordinates: Option<GeoCoordinates>,
    /// Virtual location details (if applicable)
    pub virtual_location: Option<VirtualLocation>,
    /// The parent location ID (for hierarchical locations)
    pub parent_id: Option<Uuid>,
}

impl DomainEvent for LocationDefined {
    fn aggregate_id(&self) -> Uuid {
        self.location_id
    }

    fn event_type(&self) -> &'static str {
        "LocationDefined"
    }

    fn subject(&self) -> String {
        format!("location.{}.defined", self.location_id)
    }
}





#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_domain_event_subjects() {
        let location_event = LocationDefined {
            location_id: Uuid::new_v4(),
            name: "Test Location".to_string(),
            location_type: LocationType::Physical,
            address: None,
            coordinates: None,
            virtual_location: None,
            parent_id: None,
        };

        assert!(location_event.subject().contains("location"));
        assert_eq!(location_event.event_type(), "LocationDefined");
    }

    #[test]
    fn test_event_envelope() {
        let event = LocationDefined {
            location_id: Uuid::new_v4(),
            name: "Test Location".to_string(),
            location_type: LocationType::Physical,
            address: None,
            coordinates: None,
            virtual_location: None,
            parent_id: None,
        };

        let metadata = EventMetadata {
            source: "system".to_string(),
            version: "v1".to_string(),
            propagation_scope: PropagationScope::Cluster,
            properties: std::collections::HashMap::new(),
        };

        let envelope = DomainEventEnvelope::new(event.clone(), metadata);

        assert_eq!(envelope.subject, event.subject());
        assert_eq!(envelope.metadata.propagation_scope, PropagationScope::Cluster);

        let subject = cim_subject::Subject::new(&envelope.subject).unwrap();
        assert_eq!(subject.context(), "location");
        assert!(subject.aggregate().contains(&event.location_id.to_string()));
        assert_eq!(subject.event_type(), "defined");
    }
}
