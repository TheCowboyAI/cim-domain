//! Domain events for CIM
//!
//! Events represent facts that have occurred in the domain. They are immutable
//! and form the basis of event sourcing and event-driven communication.

use crate::{
    cqrs::{CorrelationId, CausationId, EventId, IdType},
    person::IdentityComponent,
    location::{Address, LocationType, GeoCoordinates, VirtualLocation},
    organization::{OrganizationType, OrganizationRole, OrganizationStatus},
};
use cim_subject::Subject as SubjectParts;
use cid::Cid;
use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use uuid::Uuid;

/// Propagation scope for event escalation (orthogonal to subjects)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PropagationScope {
    /// Never leaves the app
    LocalOnly,
    /// May bubble to container
    Container,
    /// May bubble to local leaf
    Leaf,
    /// May bubble to cluster
    Cluster,
    /// May bubble globally
    SuperCluster,
}

/// Event envelope with subject and propagation scope
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventEnvelope<E> {
    /// The domain event
    pub event: E,
    /// Subject for routing (e.g., "people.person.registered.v1")
    pub subject: String,
    /// Determines if/how to escalate
    pub propagation: PropagationScope,
}

/// Base trait for all domain events
pub trait DomainEvent: Send + Sync + std::fmt::Debug {
    /// Get the subject for this event
    fn subject(&self) -> String;

    /// Get the aggregate ID this event relates to
    fn aggregate_id(&self) -> Uuid;

    /// Get the event type name
    fn event_type(&self) -> &'static str;

    /// Get the schema version
    fn version(&self) -> &'static str {
        "v1"
    }
}

/// Envelope for domain events with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEventEnvelopeWithMetadata<E: DomainEvent> {
    /// The event ID
    pub event_id: EventId,

    /// The actual event
    pub event: E,

    /// When the event occurred
    pub occurred_at: SystemTime,

    /// Correlation ID for tracking across services
    pub correlation_id: CorrelationId,

    /// ID of the event that caused this one
    pub causation_id: CausationId,

    /// Metadata for routing and processing
    pub metadata: EventMetadata,
}

/// Metadata for event processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventMetadata {
    /// Source service/context
    pub source: String,

    /// Event version
    pub version: String,

    /// Propagation scope
    pub propagation_scope: PropagationScope,

    /// Additional metadata
    pub properties: std::collections::HashMap<String, serde_json::Value>,
}

/// Wrapper for domain events with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEventEnvelope<E> {
    /// Event metadata
    pub metadata: EventMetadata,

    /// The actual event
    pub event: E,

    /// NATS subject for routing
    pub subject: String,
}

impl<E: DomainEvent> DomainEventEnvelope<E> {
    /// Create a new event envelope
    pub fn new(event: E, metadata: EventMetadata) -> Self {
        let subject = event.subject();
        Self {
            metadata,
            event,
            subject,
        }
    }

    /// Parse the subject into components
    pub fn subject_parts(&self) -> crate::DomainResult<SubjectParts> {
        SubjectParts::new(&self.subject).map_err(|e| crate::DomainError::InvalidSubject(e.to_string()))
    }
}

impl<E: DomainEvent> DomainEventEnvelopeWithMetadata<E> {
    /// Create a new event envelope
    /// Note: event_id (CID) will be generated by the event store from the content
    pub fn new(event: E, triggered_by: String) -> Self {
        Self {
            event_id: Cid::default(), // Placeholder - will be replaced by event store
            event,
            occurred_at: SystemTime::now(),
            correlation_id: CorrelationId(IdType::Uuid(Uuid::new_v4())),
            causation_id: CausationId(IdType::Uuid(Uuid::new_v4())),
            metadata: EventMetadata {
                source: triggered_by,
                version: "v1".to_string(),
                propagation_scope: PropagationScope::LocalOnly,
                properties: std::collections::HashMap::new(),
            },
        }
    }

    /// Create from a command
    /// Note: event_id (CID) will be generated by the event store from the content
    pub fn from_command(event: E, command_id: Uuid, triggered_by: String) -> Self {
        Self {
            event_id: Cid::default(), // Placeholder - will be replaced by event store
            event,
            occurred_at: SystemTime::now(),
            correlation_id: CorrelationId(IdType::Uuid(command_id)),
            causation_id: CausationId(IdType::Uuid(command_id)),
            metadata: EventMetadata {
                source: triggered_by,
                version: "v1".to_string(),
                propagation_scope: PropagationScope::LocalOnly,
                properties: std::collections::HashMap::new(),
            },
        }
    }

    /// Create from another event (for event chains)
    /// Note: event_id (CID) will be generated by the event store from the content
    pub fn from_event(
        event: E,
        causing_event: EventId,
        correlation_id: CorrelationId,
        triggered_by: String,
    ) -> Self {
        Self {
            event_id: Cid::default(), // Placeholder - will be replaced by event store
            event,
            occurred_at: SystemTime::now(),
            correlation_id,
            causation_id: CausationId(IdType::Cid(causing_event)),
            metadata: EventMetadata {
                source: triggered_by,
                version: "v1".to_string(),
                propagation_scope: PropagationScope::LocalOnly,
                properties: std::collections::HashMap::new(),
            },
        }
    }

    /// Set propagation scope
    pub fn with_propagation(mut self, scope: PropagationScope) -> Self {
        self.metadata.propagation_scope = scope;
        self
    }

    /// Set the actual CID after it's been calculated from content
    pub fn with_cid(mut self, cid: Cid) -> Self {
        self.event_id = cid;
        self
    }
}

// Example domain events for core entities

/// Organization was created
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationCreated {
    /// The unique identifier of the organization
    pub organization_id: Uuid,
    /// The name of the organization
    pub name: String,
    /// The type of organization (e.g., Company, Department, Team)
    pub org_type: OrganizationType,
    /// The parent organization ID if this is a sub-organization
    pub parent_id: Option<Uuid>,
    /// The primary location ID for this organization
    pub primary_location_id: Option<Uuid>,
    /// When the organization was created
    pub created_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationCreated {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationCreated"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.created.v1")
    }
}

/// Member was added to organization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationMemberAdded {
    /// The organization receiving the new member
    pub organization_id: Uuid,
    /// The person being added as a member
    pub person_id: Uuid,
    /// The role assigned to the member in this organization
    pub role: OrganizationRole,
    /// The ID of the person this member reports to (if applicable)
    pub reports_to: Option<Uuid>,
    /// When the member joined the organization
    pub joined_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationMemberAdded {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationMemberAdded"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.member_added.v1")
    }
}

/// Member was removed from organization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationMemberRemoved {
    pub organization_id: Uuid,
    pub person_id: Uuid,
    pub removed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationMemberRemoved {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationMemberRemoved"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.member_removed.v1")
    }
}

/// Member role was removed (before adding new role)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemberRoleRemoved {
    pub organization_id: Uuid,
    pub person_id: Uuid,
    pub role: OrganizationRole,
    pub removed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for MemberRoleRemoved {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "MemberRoleRemoved"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.member_role_removed.v1")
    }
}

/// Member role was assigned (after removing old role)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemberRoleAssigned {
    pub organization_id: Uuid,
    pub person_id: Uuid,
    pub role: OrganizationRole,
    pub assigned_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for MemberRoleAssigned {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "MemberRoleAssigned"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.member_role_assigned.v1")
    }
}

/// Organization parent was removed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationParentRemoved {
    pub organization_id: Uuid,
    pub parent_id: Uuid,
    pub removed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationParentRemoved {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationParentRemoved"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.parent_removed.v1")
    }
}

/// Organization parent was set
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationParentSet {
    pub organization_id: Uuid,
    pub parent_id: Uuid,
    pub set_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationParentSet {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationParentSet"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.parent_set.v1")
    }
}

/// Organization child units were added
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationChildUnitsAdded {
    pub organization_id: Uuid,
    pub child_units: Vec<Uuid>,
    pub added_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationChildUnitsAdded {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationChildUnitsAdded"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.child_units_added.v1")
    }
}

/// Organization child units were removed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationChildUnitsRemoved {
    pub organization_id: Uuid,
    pub child_units: Vec<Uuid>,
    pub removed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationChildUnitsRemoved {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationChildUnitsRemoved"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.child_units_removed.v1")
    }
}

/// Organization locations were added
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationLocationsAdded {
    pub organization_id: Uuid,
    pub locations: Vec<Uuid>,
    pub added_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationLocationsAdded {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationLocationsAdded"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.locations_added.v1")
    }
}

/// Organization locations were removed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationLocationsRemoved {
    pub organization_id: Uuid,
    pub locations: Vec<Uuid>,
    pub removed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationLocationsRemoved {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationLocationsRemoved"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.locations_removed.v1")
    }
}

/// Organization primary location was removed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationPrimaryLocationRemoved {
    pub organization_id: Uuid,
    pub location_id: Uuid,
    pub removed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationPrimaryLocationRemoved {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationPrimaryLocationRemoved"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.primary_location_removed.v1")
    }
}

/// Organization primary location was set
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationPrimaryLocationSet {
    pub organization_id: Uuid,
    pub location_id: Uuid,
    pub set_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationPrimaryLocationSet {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationPrimaryLocationSet"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.primary_location_set.v1")
    }
}

/// Organization status changed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrganizationStatusChanged {
    pub organization_id: Uuid,
    pub old_status: OrganizationStatus,
    pub new_status: OrganizationStatus,
    pub reason: Option<String>,
    pub changed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for OrganizationStatusChanged {
    fn aggregate_id(&self) -> Uuid {
        self.organization_id
    }

    fn event_type(&self) -> &'static str {
        "OrganizationStatusChanged"
    }

    fn subject(&self) -> String {
        format!("organizations.organization.status_changed.v1")
    }
}

/// Agent deployed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentDeployed {
    /// The unique identifier of the agent
    pub agent_id: Uuid,
    /// The type of agent being deployed
    pub agent_type: crate::AgentType,
    /// The ID of the entity that owns this agent
    pub owner_id: Uuid,
    /// Additional metadata about the agent
    pub metadata: crate::AgentMetadata,
    /// When the agent was deployed
    pub deployed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentDeployed {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentDeployed"
    }

    fn subject(&self) -> String {
        format!("agents.agent.deployed.v1")
    }
}

/// Agent activated
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentActivated {
    /// The ID of the agent being activated
    pub agent_id: Uuid,
    /// When the agent was activated
    pub activated_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentActivated {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentActivated"
    }

    fn subject(&self) -> String {
        format!("agents.agent.activated.v1")
    }
}

/// Agent suspended
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentSuspended {
    /// The ID of the agent being suspended
    pub agent_id: Uuid,
    /// The reason for suspension
    pub reason: String,
    /// When the agent was suspended
    pub suspended_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentSuspended {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentSuspended"
    }

    fn subject(&self) -> String {
        format!("agents.agent.suspended.v1")
    }
}

/// Agent went offline
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentWentOffline {
    /// The ID of the agent that went offline
    pub agent_id: Uuid,
    /// When the agent went offline
    pub offline_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentWentOffline {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentWentOffline"
    }

    fn subject(&self) -> String {
        format!("agents.agent.went_offline.v1")
    }
}

/// Agent decommissioned
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentDecommissioned {
    /// The ID of the agent being decommissioned
    pub agent_id: Uuid,
    /// When the agent was decommissioned
    pub decommissioned_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentDecommissioned {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentDecommissioned"
    }

    fn subject(&self) -> String {
        format!("agents.agent.decommissioned.v1")
    }
}

/// Agent capabilities added
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentCapabilitiesAdded {
    /// The ID of the agent receiving new capabilities
    pub agent_id: Uuid,
    /// The list of capabilities being added
    pub capabilities: Vec<String>,
    /// When the capabilities were added
    pub added_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentCapabilitiesAdded {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentCapabilitiesAdded"
    }

    fn subject(&self) -> String {
        format!("agents.agent.capabilities_added.v1")
    }
}

/// Agent capabilities removed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentCapabilitiesRemoved {
    /// The ID of the agent losing capabilities
    pub agent_id: Uuid,
    /// The list of capabilities being removed
    pub capabilities: Vec<String>,
    /// When the capabilities were removed
    pub removed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentCapabilitiesRemoved {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentCapabilitiesRemoved"
    }

    fn subject(&self) -> String {
        format!("agents.agent.capabilities_removed.v1")
    }
}

/// Agent permissions granted
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentPermissionsGranted {
    /// The ID of the agent receiving permissions
    pub agent_id: Uuid,
    /// The list of permissions being granted
    pub permissions: Vec<String>,
    /// When the permissions were granted
    pub granted_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentPermissionsGranted {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentPermissionsGranted"
    }

    fn subject(&self) -> String {
        format!("agents.agent.permissions_granted.v1")
    }
}

/// Agent permissions revoked
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentPermissionsRevoked {
    /// The ID of the agent losing permissions
    pub agent_id: Uuid,
    /// The list of permissions being revoked
    pub permissions: Vec<String>,
    /// When the permissions were revoked
    pub revoked_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentPermissionsRevoked {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentPermissionsRevoked"
    }

    fn subject(&self) -> String {
        format!("agents.agent.permissions_revoked.v1")
    }
}

/// Agent tools enabled
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentToolsEnabled {
    /// The ID of the agent receiving tools
    pub agent_id: Uuid,
    /// The list of tools being enabled
    pub tools: Vec<crate::ToolDefinition>,
    /// When the tools were enabled
    pub enabled_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentToolsEnabled {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentToolsEnabled"
    }

    fn subject(&self) -> String {
        format!("agents.agent.tools_enabled.v1")
    }
}

/// Agent tools disabled
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentToolsDisabled {
    /// The ID of the agent losing tools
    pub agent_id: Uuid,
    /// The names of tools being disabled
    pub tool_names: Vec<String>,
    /// When the tools were disabled
    pub disabled_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentToolsDisabled {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentToolsDisabled"
    }

    fn subject(&self) -> String {
        format!("agents.agent.tools_disabled.v1")
    }
}

/// Agent configuration updated (removed old, added new)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentConfigurationRemoved {
    /// The ID of the agent whose configuration is being removed
    pub agent_id: Uuid,
    /// The old configuration being removed
    pub old_config: serde_json::Value,
    /// When the configuration was removed
    pub removed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentConfigurationRemoved {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentConfigurationRemoved"
    }

    fn subject(&self) -> String {
        format!("agents.agent.configuration_removed.v1")
    }
}

/// Agent configuration set
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentConfigurationSet {
    /// The ID of the agent receiving new configuration
    pub agent_id: Uuid,
    /// The new configuration being set
    pub new_config: serde_json::Value,
    /// The version of the configuration
    pub version: String,
    /// When the configuration was set
    pub set_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for AgentConfigurationSet {
    fn aggregate_id(&self) -> Uuid {
        self.agent_id
    }

    fn event_type(&self) -> &'static str {
        "AgentConfigurationSet"
    }

    fn subject(&self) -> String {
        format!("agents.agent.configuration_set.v1")
    }
}

/// Location defined
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocationDefined {
    /// The unique identifier of the location
    pub location_id: Uuid,
    /// The name of the location
    pub name: String,
    /// The type of location (physical, virtual, etc.)
    pub location_type: LocationType,
    /// The physical address (if applicable)
    pub address: Option<Address>,
    /// The geographic coordinates (if applicable)
    pub coordinates: Option<GeoCoordinates>,
    /// Virtual location details (if applicable)
    pub virtual_location: Option<VirtualLocation>,
    /// The parent location ID (for hierarchical locations)
    pub parent_id: Option<Uuid>,
}

impl DomainEvent for LocationDefined {
    fn aggregate_id(&self) -> Uuid {
        self.location_id
    }

    fn event_type(&self) -> &'static str {
        "LocationDefined"
    }

    fn subject(&self) -> String {
        format!("location.{}.defined", self.location_id)
    }
}

/// Policy enacted
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyEnacted {
    /// The unique identifier of the policy
    pub policy_id: Uuid,
    /// The type of policy being enacted
    pub policy_type: crate::PolicyType,
    /// The scope of the policy's application
    pub scope: crate::PolicyScope,
    /// The ID of the entity that owns this policy
    pub owner_id: Uuid,
    /// Additional metadata about the policy
    pub metadata: crate::PolicyMetadata,
    /// When the policy was enacted
    pub enacted_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicyEnacted {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicyEnacted"
    }

    fn subject(&self) -> String {
        format!("policies.policy.enacted.v1")
    }
}

/// Policy submitted for approval
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicySubmittedForApproval {
    /// The ID of the policy being submitted
    pub policy_id: Uuid,
    /// The ID of the user who submitted the policy
    pub submitted_by: Uuid,
    /// When the policy was submitted
    pub submitted_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicySubmittedForApproval {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicySubmittedForApproval"
    }

    fn subject(&self) -> String {
        format!("policies.policy.submitted_for_approval.v1")
    }
}

/// Policy approved
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyApproved {
    /// The ID of the policy being approved
    pub policy_id: Uuid,
    /// The ID of the user who approved the policy
    pub approved_by: Uuid,
    /// Optional detailed approval information
    pub approval_details: Option<crate::Approval>,
    /// When the policy was approved
    pub approved_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicyApproved {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicyApproved"
    }

    fn subject(&self) -> String {
        format!("policies.policy.approved.v1")
    }
}

/// Policy rejected
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyRejected {
    /// The ID of the policy being rejected
    pub policy_id: Uuid,
    /// The ID of the user who rejected the policy
    pub rejected_by: Uuid,
    /// The reason for rejection
    pub reason: String,
    /// When the policy was rejected
    pub rejected_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicyRejected {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicyRejected"
    }

    fn subject(&self) -> String {
        format!("policies.policy.rejected.v1")
    }
}

/// Policy suspended
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicySuspended {
    /// The ID of the policy being suspended
    pub policy_id: Uuid,
    /// The ID of the user who suspended the policy
    pub suspended_by: Uuid,
    /// The reason for suspension
    pub reason: String,
    /// When the policy was suspended
    pub suspended_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicySuspended {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicySuspended"
    }

    fn subject(&self) -> String {
        format!("policies.policy.suspended.v1")
    }
}

/// Policy reactivated
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyReactivated {
    /// The ID of the policy being reactivated
    pub policy_id: Uuid,
    /// The ID of the user who reactivated the policy
    pub reactivated_by: Uuid,
    /// When the policy was reactivated
    pub reactivated_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicyReactivated {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicyReactivated"
    }

    fn subject(&self) -> String {
        format!("policies.policy.reactivated.v1")
    }
}

/// Policy superseded
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicySuperseded {
    /// The ID of the policy being superseded
    pub policy_id: Uuid,
    /// The ID of the new policy that supersedes this one
    pub superseded_by_policy_id: Uuid,
    /// When the policy was superseded
    pub superseded_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicySuperseded {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicySuperseded"
    }

    fn subject(&self) -> String {
        format!("policies.policy.superseded.v1")
    }
}

/// Policy archived
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyArchived {
    /// The ID of the policy being archived
    pub policy_id: Uuid,
    /// The ID of the user who archived the policy
    pub archived_by: Uuid,
    /// When the policy was archived
    pub archived_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicyArchived {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicyArchived"
    }

    fn subject(&self) -> String {
        format!("policies.policy.archived.v1")
    }
}

/// External approval requested
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyExternalApprovalRequested {
    /// The ID of the policy requiring external approval
    pub policy_id: Uuid,
    /// The unique ID of this approval request
    pub request_id: Uuid,
    /// The type of approval being requested
    pub approval_type: String,
    /// The ID of the entity from whom approval is requested
    pub requested_from: Uuid,
    /// When the approval request expires (if applicable)
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    /// When the approval was requested
    pub requested_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicyExternalApprovalRequested {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicyExternalApprovalRequested"
    }

    fn subject(&self) -> String {
        format!("policies.policy.external_approval_requested.v1")
    }
}

/// External approval received
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PolicyExternalApprovalReceived {
    /// The ID of the policy that received approval
    pub policy_id: Uuid,
    /// The ID of the approval request being fulfilled
    pub request_id: Uuid,
    /// The verification details of the external approval
    pub verification: crate::ExternalVerification,
    /// When the approval was received
    pub received_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for PolicyExternalApprovalReceived {
    fn aggregate_id(&self) -> Uuid {
        self.policy_id
    }

    fn event_type(&self) -> &'static str {
        "PolicyExternalApprovalReceived"
    }

    fn subject(&self) -> String {
        format!("policies.policy.external_approval_received.v1")
    }
}

// Document Events

/// Document was uploaded to the system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentUploaded {
    /// Document's unique ID
    pub document_id: Uuid,
    /// Document info
    pub info: crate::DocumentInfoComponent,
    /// Content CID
    pub content_cid: Cid,
    /// Whether document is chunked
    pub is_chunked: bool,
    /// Chunk CIDs if chunked
    pub chunk_cids: Vec<Cid>,
    /// Uploaded by
    pub uploaded_by: Uuid,
    /// Uploaded at
    pub uploaded_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentUploaded {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentUploaded"
    }

    fn subject(&self) -> String {
        format!("documents.document.uploaded.v1")
    }
}

/// Document was classified
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentClassified {
    /// The ID of the document being classified
    pub document_id: Uuid,
    /// The classification details
    pub classification: crate::ClassificationComponent,
    /// The ID of the user who classified the document
    pub classified_by: Uuid,
    /// When the document was classified
    pub classified_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentClassified {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentClassified"
    }

    fn subject(&self) -> String {
        format!("documents.document.classified.v1")
    }
}

/// Document ownership was assigned
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentOwnershipAssigned {
    /// The ID of the document receiving ownership
    pub document_id: Uuid,
    /// The ownership details
    pub ownership: crate::OwnershipComponent,
    /// When the ownership was assigned
    pub assigned_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentOwnershipAssigned {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentOwnershipAssigned"
    }

    fn subject(&self) -> String {
        format!("documents.document.ownership_assigned.v1")
    }
}

/// Document access control was set
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentAccessControlSet {
    /// The ID of the document receiving access control
    pub document_id: Uuid,
    /// The access control details
    pub access_control: crate::AccessControlComponent,
    /// The ID of the user who set the access control
    pub set_by: Uuid,
    /// When the access control was set
    pub set_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentAccessControlSet {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentAccessControlSet"
    }

    fn subject(&self) -> String {
        format!("documents.document.access_control_set.v1")
    }
}

/// Document status was set
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentStatusSet {
    /// The ID of the document whose status is changing
    pub document_id: Uuid,
    /// The previous status
    pub old_status: crate::DocumentStatus,
    /// The new status
    pub new_status: crate::DocumentStatus,
    /// The ID of the user who set the status
    pub set_by: Uuid,
    /// Optional reason for the status change
    pub reason: Option<String>,
    /// When the status was set
    pub set_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentStatusSet {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentStatusSet"
    }

    fn subject(&self) -> String {
        format!("documents.document.status_set.v1")
    }
}

/// Document was processed (text extraction, OCR, etc.)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentProcessed {
    /// The ID of the document that was processed
    pub document_id: Uuid,
    /// The processing details
    pub processing: crate::ProcessingComponent,
    /// When the document was processed
    pub processed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentProcessed {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentProcessed"
    }

    fn subject(&self) -> String {
        format!("documents.document.processed.v1")
    }
}

/// Document relationship was added
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentRelationshipAdded {
    /// The ID of the primary document
    pub document_id: Uuid,
    /// The ID of the related document
    pub related_document_id: Uuid,
    /// The type of relationship
    pub relation_type: crate::RelationType,
    /// Optional description of the relationship
    pub description: Option<String>,
    /// The ID of the user who added the relationship
    pub added_by: Uuid,
    /// When the relationship was added
    pub added_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentRelationshipAdded {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentRelationshipAdded"
    }

    fn subject(&self) -> String {
        format!("documents.document.relationship_added.v1")
    }
}

/// Document relationship was removed
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentRelationshipRemoved {
    /// The ID of the primary document
    pub document_id: Uuid,
    /// The ID of the related document
    pub related_document_id: Uuid,
    /// The ID of the user who removed the relationship
    pub removed_by: Uuid,
    /// When the relationship was removed
    pub removed_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentRelationshipRemoved {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentRelationshipRemoved"
    }

    fn subject(&self) -> String {
        format!("documents.document.relationship_removed.v1")
    }
}

/// Document version was created
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentVersionCreated {
    /// The ID of the document being versioned
    pub document_id: Uuid,
    /// The ID of the new version
    pub new_version_id: Uuid,
    /// The version number/label
    pub version_number: String,
    /// The CID of the previous version's content
    pub previous_version_cid: Cid,
    /// The CID of the new version's content
    pub new_content_cid: Cid,
    /// The ID of the user who created the version
    pub created_by: Uuid,
    /// When the version was created
    pub created_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentVersionCreated {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentVersionCreated"
    }

    fn subject(&self) -> String {
        format!("documents.document.version_created.v1")
    }
}

/// Document was archived
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DocumentArchived {
    /// The ID of the document being archived
    pub document_id: Uuid,
    /// The ID of the user who archived the document
    pub archived_by: Uuid,
    /// Optional reason for archiving
    pub reason: Option<String>,
    /// When the document was archived
    pub archived_at: chrono::DateTime<chrono::Utc>,
}

impl DomainEvent for DocumentArchived {
    fn aggregate_id(&self) -> Uuid {
        self.document_id
    }

    fn event_type(&self) -> &'static str {
        "DocumentArchived"
    }

    fn subject(&self) -> String {
        format!("documents.document.archived.v1")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_person_registered_event() {
        let event = PersonRegistered {
            person_id: Uuid::new_v4(),
            identity: IdentityComponent {
                legal_name: "Alice Smith".to_string(),
                preferred_name: Some("Alice".to_string()),
                date_of_birth: None,
                government_id: None,
            },
            contact: None,
            location_id: None,
            registered_at: chrono::Utc::now(),
        };

        assert_eq!(event.aggregate_id(), event.person_id);
        assert_eq!(event.event_type(), "PersonRegistered");
        assert_eq!(event.subject(), "people.person.registered.v1");
        assert_eq!(event.version(), "v1");
    }

    #[test]
    fn test_domain_event_subjects() {
        let person_event = PersonRegistered {
            person_id: Uuid::new_v4(),
            identity: IdentityComponent {
                legal_name: "John Doe".to_string(),
                preferred_name: Some("John".to_string()),
                date_of_birth: None,
                government_id: None,
            },
            contact: None,
            location_id: None,
            registered_at: chrono::Utc::now(),
        };

        assert_eq!(person_event.subject(), "people.person.registered.v1");

        let org_event = OrganizationCreated {
            organization_id: Uuid::new_v4(),
            name: "Acme Corp".to_string(),
            org_type: OrganizationType::Company,
            parent_id: None,
            primary_location_id: None,
            created_at: chrono::Utc::now(),
        };

        assert_eq!(org_event.subject(), "organizations.organization.created.v1");
    }

    #[test]
    fn test_event_envelope() {
        let event = OrganizationCreated {
            organization_id: Uuid::new_v4(),
            name: "Acme Corp".to_string(),
            org_type: OrganizationType::Company,
            parent_id: None,
            primary_location_id: None,
            created_at: chrono::Utc::now(),
        };

        let metadata = EventMetadata {
            source: "system".to_string(),
            version: "v1".to_string(),
            propagation_scope: PropagationScope::Cluster,
            properties: std::collections::HashMap::new(),
        };

        let envelope = DomainEventEnvelope::new(event, metadata);

        assert_eq!(envelope.subject, "organizations.organization.created.v1");
        assert_eq!(envelope.metadata.propagation_scope, PropagationScope::Cluster);

        let subject = cim_subject::Subject::new(&envelope.subject).unwrap();
        assert_eq!(subject.context(), "organizations");
        assert_eq!(subject.aggregate(), "organization");
        assert_eq!(subject.event_type(), "created");
        assert_eq!(subject.version(), "v1");
    }
}
