//! Domain events for CIM
//!
//! Events represent facts that have occurred in the domain. They are immutable
//! and form the basis of event sourcing and event-driven communication.

use crate::{
    cqrs::{CorrelationId, CausationId, EventId, IdType},
};
use cim_subject::{Subject as SubjectParts, SerializableCid};
use cid::Cid;
use serde::{Deserialize, Serialize};
use std::time::SystemTime;
use uuid::Uuid;

/// Propagation scope for event escalation (orthogonal to subjects)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum PropagationScope {
    /// Never leaves the app
    LocalOnly,
    /// May bubble to container
    Container,
    /// May bubble to local leaf
    Leaf,
    /// May bubble to cluster
    Cluster,
    /// May bubble globally
    SuperCluster,
}

/// Event envelope with subject and propagation scope
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventEnvelope<E> {
    /// The domain event
    pub event: E,
    /// Subject for routing (e.g., "people.person.registered.v1")
    pub subject: String,
    /// Determines if/how to escalate
    pub propagation: PropagationScope,
}

/// Base trait for all domain events
pub trait DomainEvent: Send + Sync + std::fmt::Debug {
    /// Get the subject for this event
    fn subject(&self) -> String;

    /// Get the aggregate ID this event relates to
    fn aggregate_id(&self) -> Uuid;

    /// Get the event type name
    fn event_type(&self) -> &'static str;

    /// Get the schema version
    fn version(&self) -> &'static str {
        "v1"
    }
}

/// Envelope for domain events with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEventEnvelopeWithMetadata<E: DomainEvent> {
    /// The event ID
    pub event_id: EventId,

    /// The actual event
    pub event: E,

    /// When the event occurred
    pub occurred_at: SystemTime,

    /// Correlation ID for tracking across services
    pub correlation_id: CorrelationId,

    /// ID of the event that caused this one
    pub causation_id: CausationId,

    /// Metadata for routing and processing
    pub metadata: EventMetadata,
}

/// Metadata for event processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventMetadata {
    /// Source service/context
    pub source: String,

    /// Event version
    pub version: String,

    /// Propagation scope
    pub propagation_scope: PropagationScope,

    /// Additional metadata
    pub properties: std::collections::HashMap<String, serde_json::Value>,
}

/// Wrapper for domain events with metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DomainEventEnvelope<E> {
    /// Event metadata
    pub metadata: EventMetadata,

    /// The actual event
    pub event: E,

    /// NATS subject for routing
    pub subject: String,
}

impl<E: DomainEvent> DomainEventEnvelope<E> {
    /// Create a new event envelope
    pub fn new(event: E, metadata: EventMetadata) -> Self {
        let subject = event.subject();
        Self {
            metadata,
            event,
            subject,
        }
    }

    /// Parse the subject into components
    pub fn subject_parts(&self) -> crate::DomainResult<SubjectParts> {
        SubjectParts::new(&self.subject).map_err(|e| crate::DomainError::InvalidSubject(e.to_string()))
    }
}

impl<E: DomainEvent> DomainEventEnvelopeWithMetadata<E> {
    /// Create a new event envelope
    /// Note: event_id (CID) will be generated by the event store from the content
    pub fn new(event: E, triggered_by: String) -> Self {
        Self {
            event_id: Cid::default(), // Placeholder - will be replaced by event store
            event,
            occurred_at: SystemTime::now(),
            correlation_id: CorrelationId(IdType::Uuid(Uuid::new_v4())),
            causation_id: CausationId(IdType::Uuid(Uuid::new_v4())),
            metadata: EventMetadata {
                source: triggered_by,
                version: "v1".to_string(),
                propagation_scope: PropagationScope::LocalOnly,
                properties: std::collections::HashMap::new(),
            },
        }
    }

    /// Create from a command
    /// Note: event_id (CID) will be generated by the event store from the content
    pub fn from_command(event: E, command_id: Uuid, triggered_by: String) -> Self {
        Self {
            event_id: Cid::default(), // Placeholder - will be replaced by event store
            event,
            occurred_at: SystemTime::now(),
            correlation_id: CorrelationId(IdType::Uuid(command_id)),
            causation_id: CausationId(IdType::Uuid(command_id)),
            metadata: EventMetadata {
                source: triggered_by,
                version: "v1".to_string(),
                propagation_scope: PropagationScope::LocalOnly,
                properties: std::collections::HashMap::new(),
            },
        }
    }

    /// Create from another event (for event chains)
    /// Note: event_id (CID) will be generated by the event store from the content
    pub fn from_event(
        event: E,
        causing_event: EventId,
        correlation_id: CorrelationId,
        triggered_by: String,
    ) -> Self {
        Self {
            event_id: Cid::default(), // Placeholder - will be replaced by event store
            event,
            occurred_at: SystemTime::now(),
            correlation_id,
            causation_id: CausationId(IdType::Cid(SerializableCid(causing_event))),
            metadata: EventMetadata {
                source: triggered_by,
                version: "v1".to_string(),
                propagation_scope: PropagationScope::LocalOnly,
                properties: std::collections::HashMap::new(),
            },
        }
    }

    /// Set propagation scope
    pub fn with_propagation(mut self, scope: PropagationScope) -> Self {
        self.metadata.propagation_scope = scope;
        self
    }

    /// Set the actual CID after it's been calculated from content
    pub fn with_cid(mut self, cid: Cid) -> Self {
        self.event_id = cid;
        self
    }
}

// All domain-specific events have been moved to their respective domain submodules:
// - Person events: cim-domain-person
// - Organization events: cim-domain-organization
// - Agent events: cim-domain-agent
// - Workflow events: cim-domain-workflow
// - Location events: cim-domain-location
// - Document events: cim-domain-document
// - Policy events: cim-domain-policy
