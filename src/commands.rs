//! Domain commands for CIM
//!
//! Commands represent requests to change state. They are processed by command handlers
//! which validate business rules and emit events. Commands return only acknowledgments,
//! not data - use queries for data retrieval.

use crate::{
    cqrs::Command,
    entity::EntityId,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Agent Commands

/// Deploy a new agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeployAgent {
    /// Agent's unique ID (generated by caller)
    pub agent_id: Uuid,
    /// Agent type
    pub agent_type: crate::AgentType,
    /// Owner (person or organization)
    pub owner_id: Uuid,
    /// Agent metadata
    pub metadata: crate::AgentMetadata,
}

impl Command for DeployAgent {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Activate an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActivateAgent {
    /// The ID of the agent to activate
    pub agent_id: Uuid,
}

impl Command for ActivateAgent {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Suspend an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuspendAgent {
    /// The ID of the agent to suspend
    pub agent_id: Uuid,
    /// The reason for suspension
    pub reason: String,
}

impl Command for SuspendAgent {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Set agent offline
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetAgentOffline {
    /// The ID of the agent to set offline
    pub agent_id: Uuid,
}

impl Command for SetAgentOffline {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Decommission an agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecommissionAgent {
    /// The ID of the agent to decommission
    pub agent_id: Uuid,
}

impl Command for DecommissionAgent {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Update agent capabilities
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateAgentCapabilities {
    /// Agent ID
    pub agent_id: Uuid,
    /// New capabilities to add
    pub add_capabilities: Vec<String>,
    /// Capabilities to remove
    pub remove_capabilities: Vec<String>,
}

impl Command for UpdateAgentCapabilities {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Grant permissions to agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GrantAgentPermissions {
    /// The ID of the agent to grant permissions to
    pub agent_id: Uuid,
    /// The list of permissions to grant
    pub permissions: Vec<String>,
}

impl Command for GrantAgentPermissions {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Revoke permissions from agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RevokeAgentPermissions {
    /// The ID of the agent to revoke permissions from
    pub agent_id: Uuid,
    /// The list of permissions to revoke
    pub permissions: Vec<String>,
}

impl Command for RevokeAgentPermissions {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Enable tools for agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnableAgentTools {
    /// The ID of the agent to enable tools for
    pub agent_id: Uuid,
    /// The list of tools to enable
    pub tools: Vec<crate::ToolDefinition>,
}

impl Command for EnableAgentTools {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Disable tools for agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DisableAgentTools {
    /// The ID of the agent to disable tools for
    pub agent_id: Uuid,
    /// The names of tools to disable
    pub tool_names: Vec<String>,
}

impl Command for DisableAgentTools {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

/// Update agent configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateAgentConfiguration {
    /// The ID of the agent to update configuration for
    pub agent_id: Uuid,
    /// The new configuration
    pub config: serde_json::Value,
    /// The version of the configuration
    pub version: String,
}

impl Command for UpdateAgentConfiguration {
    type Aggregate = crate::Agent;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.agent_id))
    }
}

// Location Commands

/// Define a new location
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DefineLocation {
    /// Location's unique ID (generated by caller)
    pub location_id: Uuid,
    /// Location name
    pub name: String,
    /// Location type (physical, virtual, logical, hybrid)
    pub location_type: crate::LocationType,
    /// Physical address (for physical locations)
    pub address: Option<crate::Address>,
    /// Geographic coordinates (for physical locations)
    pub coordinates: Option<crate::GeoCoordinates>,
    /// Virtual location details (for virtual locations)
    pub virtual_location: Option<crate::VirtualLocation>,
    /// Parent location (for hierarchies)
    pub parent_id: Option<Uuid>,
    /// Additional metadata
    pub metadata: std::collections::HashMap<String, String>,
}

impl Command for DefineLocation {
    type Aggregate = LocationAggregate;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.location_id))
    }
}

// Policy Commands

/// Enact a new policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnactPolicy {
    /// Policy's unique ID (generated by caller)
    pub policy_id: Uuid,
    /// Policy type
    pub policy_type: crate::PolicyType,
    /// Scope of application
    pub scope: crate::PolicyScope,
    /// Owner ID
    pub owner_id: Uuid,
    /// Policy metadata
    pub metadata: crate::PolicyMetadata,
}

impl Command for EnactPolicy {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Submit policy for approval
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubmitPolicyForApproval {
    /// The ID of the policy to submit
    pub policy_id: Uuid,
    /// The ID of the user submitting the policy
    pub submitted_by: Uuid,
}

impl Command for SubmitPolicyForApproval {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Approve a policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApprovePolicy {
    /// The ID of the policy to approve
    pub policy_id: Uuid,
    /// The ID of the user approving the policy
    pub approved_by: Uuid,
    /// Optional detailed approval information
    pub approval_details: Option<crate::Approval>,
}

impl Command for ApprovePolicy {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Reject a policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RejectPolicy {
    /// The ID of the policy to reject
    pub policy_id: Uuid,
    /// The ID of the user rejecting the policy
    pub rejected_by: Uuid,
    /// The reason for rejection
    pub reason: String,
}

impl Command for RejectPolicy {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Suspend a policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuspendPolicy {
    /// The ID of the policy to suspend
    pub policy_id: Uuid,
    /// The ID of the user suspending the policy
    pub suspended_by: Uuid,
    /// The reason for suspension
    pub reason: String,
}

impl Command for SuspendPolicy {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Reactivate a policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReactivatePolicy {
    /// The ID of the policy to reactivate
    pub policy_id: Uuid,
    /// The ID of the user reactivating the policy
    pub reactivated_by: Uuid,
}

impl Command for ReactivatePolicy {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Supersede a policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SupersedePolicy {
    /// The ID of the policy to supersede
    pub policy_id: Uuid,
    /// The ID of the new policy that supersedes this one
    pub superseded_by_policy_id: Uuid,
}

impl Command for SupersedePolicy {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Archive a policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArchivePolicy {
    /// The ID of the policy to archive
    pub policy_id: Uuid,
    /// The ID of the user archiving the policy
    pub archived_by: Uuid,
}

impl Command for ArchivePolicy {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Request external approval for a policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestPolicyExternalApproval {
    /// The ID of the policy requiring external approval
    pub policy_id: Uuid,
    /// Unique request identifier
    pub request_id: Uuid,
    /// Type of external approval required (e.g., "yubikey", "biometric")
    pub approval_type: String,
    /// ID of the entity from whom approval is requested
    pub requested_from: Uuid,
    /// When the approval request expires
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl Command for RequestPolicyExternalApproval {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Record external approval received
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecordPolicyExternalApproval {
    /// The ID of the policy that received external approval
    pub policy_id: Uuid,
    /// The request ID this approval is responding to
    pub request_id: Uuid,
    /// Verification details from the external system
    pub verification: crate::ExternalVerification,
}

impl Command for RecordPolicyExternalApproval {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

/// Update policy rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdatePolicyRules {
    /// Policy ID
    pub policy_id: Uuid,
    /// New rules (replaces existing)
    pub rules: serde_json::Value,
    /// Rule engine type
    pub engine: String,
    /// Rule version
    pub version: String,
}

impl Command for UpdatePolicyRules {
    type Aggregate = crate::Policy;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.policy_id))
    }
}

// Marker types for aggregates (these would normally be in separate aggregate modules)

/// Location aggregate marker
#[derive(Debug)]
pub struct LocationAggregate;

// Document Commands

/// Upload a new document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UploadDocument {
    /// Document's unique ID (generated by caller)
    pub document_id: Uuid,
    /// Document info
    pub info: crate::DocumentInfoComponent,
    /// Content CID
    pub content_cid: cid::Cid,
    /// Whether document is chunked
    pub is_chunked: bool,
    /// Chunk CIDs if chunked
    pub chunk_cids: Vec<cid::Cid>,
    /// Uploaded by
    pub uploaded_by: Uuid,
}

impl Command for UploadDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Classify a document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClassifyDocument {
    /// The ID of the document to classify
    pub document_id: Uuid,
    /// The classification to apply
    pub classification: crate::ClassificationComponent,
    /// The ID of the user performing the classification
    pub classified_by: Uuid,
}

impl Command for ClassifyDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Assign document ownership
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssignDocumentOwnership {
    /// The ID of the document to assign ownership
    pub document_id: Uuid,
    /// The ownership information to assign
    pub ownership: crate::OwnershipComponent,
}

impl Command for AssignDocumentOwnership {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Set document access control
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetDocumentAccessControl {
    /// The ID of the document to set access control
    pub document_id: Uuid,
    /// The access control settings to apply
    pub access_control: crate::AccessControlComponent,
    /// The ID of the user setting the access control
    pub set_by: Uuid,
}

impl Command for SetDocumentAccessControl {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Set document status
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetDocumentStatus {
    /// The ID of the document to update status
    pub document_id: Uuid,
    /// The new status to set
    pub new_status: crate::DocumentStatus,
    /// The ID of the user setting the status
    pub set_by: Uuid,
    /// Optional reason for the status change
    pub reason: Option<String>,
}

impl Command for SetDocumentStatus {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Process document (text extraction, OCR, etc.)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessDocument {
    /// The ID of the document to process
    pub document_id: Uuid,
    /// The processing results and status
    pub processing: crate::ProcessingComponent,
}

impl Command for ProcessDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Add document relationship
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddDocumentRelationship {
    /// The ID of the source document
    pub document_id: Uuid,
    /// The ID of the related document
    pub related_document_id: Uuid,
    /// The type of relationship
    pub relation_type: crate::RelationType,
    /// Optional description of the relationship
    pub description: Option<String>,
    /// The ID of the user adding the relationship
    pub added_by: Uuid,
}

impl Command for AddDocumentRelationship {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Remove document relationship
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoveDocumentRelationship {
    /// The ID of the source document
    pub document_id: Uuid,
    /// The ID of the related document to remove relationship with
    pub related_document_id: Uuid,
    /// The ID of the user removing the relationship
    pub removed_by: Uuid,
}

impl Command for RemoveDocumentRelationship {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Create document version
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateDocumentVersion {
    /// The ID of the original document
    pub document_id: Uuid,
    /// The ID for the new version
    pub new_version_id: Uuid,
    /// The version number/label
    pub version_number: String,
    /// The CID of the new version's content
    pub new_content_cid: cid::Cid,
    /// The ID of the user creating the version
    pub created_by: Uuid,
}

impl Command for CreateDocumentVersion {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

/// Archive document
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArchiveDocument {
    /// The ID of the document to archive
    pub document_id: Uuid,
    /// The ID of the user archiving the document
    pub archived_by: Uuid,
    /// Optional reason for archiving
    pub reason: Option<String>,
}

impl Command for ArchiveDocument {
    type Aggregate = crate::Document;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.document_id))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{CommandEnvelope, CorrelationId};

    #[test]
    fn test_command_aggregate_ids() {
        let agent_id = Uuid::new_v4();
        let cmd = DeployAgent {
            agent_id,
            agent_type: crate::AgentType::Assistant,
            owner_id: Uuid::new_v4(),
            metadata: crate::AgentMetadata {
                name: "Test Agent".to_string(),
                description: "Test agent for unit tests".to_string(),
                version: "1.0.0".to_string(),
                created_at: chrono::Utc::now(),
                created_by: Uuid::new_v4(),
            },
        };

        let agg_id = cmd.aggregate_id();
        assert_eq!(agg_id.unwrap().as_uuid(), &agent_id);
    }
}

