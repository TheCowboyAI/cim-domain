//! Domain commands for CIM
//!
//! Commands represent requests to change state. They are processed by command handlers
//! which validate business rules and emit events. Commands return only acknowledgments,
//! not data - use queries for data retrieval.

use crate::{
    cqrs::Command,
    entity::EntityId,
};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Location Commands

/// Define a new location
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DefineLocation {
    /// Location's unique ID (generated by caller)
    pub location_id: Uuid,
    /// Location name
    pub name: String,
    /// Location type (physical, virtual, logical, hybrid)
    pub location_type: crate::LocationType,
    /// Physical address (for physical locations)
    pub address: Option<crate::Address>,
    /// Geographic coordinates (for physical locations)
    pub coordinates: Option<crate::GeoCoordinates>,
    /// Virtual location details (for virtual locations)
    pub virtual_location: Option<crate::VirtualLocation>,
    /// Parent location (for hierarchies)
    pub parent_id: Option<Uuid>,
    /// Additional metadata
    pub metadata: std::collections::HashMap<String, String>,
}

impl Command for DefineLocation {
    type Aggregate = LocationAggregate;

    fn aggregate_id(&self) -> Option<EntityId<Self::Aggregate>> {
        Some(EntityId::from_uuid(self.location_id))
    }
}



// Marker types for aggregates (these would normally be in separate aggregate modules)

/// Location aggregate marker
#[derive(Debug)]
pub struct LocationAggregate;



#[cfg(test)]
mod tests {
    use super::*;
    use crate::{CommandEnvelope, CorrelationId};

    #[test]
    fn test_command_aggregate_ids() {
        let location_id = Uuid::new_v4();
        let cmd = DefineLocation {
            location_id,
            name: "Test Location".to_string(),
            location_type: crate::LocationType::Physical,
            address: None,
            coordinates: None,
            virtual_location: None,
            parent_id: None,
            metadata: std::collections::HashMap::new(),
        };

        let agg_id = cmd.aggregate_id();
        assert_eq!(agg_id.unwrap().as_uuid(), &location_id);
    }
}

